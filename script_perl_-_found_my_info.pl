#!/usr/bin/perl
use warnings;
use strict;
use LWP::Simple;
use JSON; #apt-get install libjson-perl
use Switch; #apt-get install libswitch-perl
sub jsonFileToArray($);
sub searchFormat($;$);
sub composeMySearch($);
sub search($$;$;$);
sub getFieldFilter($$;$);
sub getProtocole($);
sub getFirstLineField($$$);
sub getPath($);
sub getField($);
sub getValue($);
sub convertToRegex($);
sub clearScreen();
sub printArray($;$);
my $filename = 'capture_IMS';
$, = "\n";

my @data = jsonFileToArray($filename);
my @tab_pathes = searchFormat(\@data);
my $regex =  composeMySearch(\@tab_pathes);
my @search_result = search(\@tab_pathes,$regex,1);
printArray(\@search_result);


sub jsonFileToArray($) {
  my($filename) = @_;
  open(FILE, "<", "json/".$filename.".json") or die "Can't open < json/".$filename.".json: ".$!;
  my $json_str = '';
  foreach my $line (<FILE>) { $json_str .= $line; } #implode
  return @{decode_json($json_str)};
}

sub searchFormat($;$) {
  my($ref_tab,$chemin_herite) = @_;
  if(!defined $chemin_herite) {
    $chemin_herite = '';
  }
  my @tab_retour;
  if(ref($ref_tab) eq 'HASH') {
    my %tab = %{$ref_tab};
    foreach my $item (sort keys %tab) {
      my $chemin = $chemin_herite;
      if((ref($ref_tab->{$item}) eq 'HASH')or(ref($ref_tab->{$item}) eq 'ARRAY')) {
        $chemin .= $item."///";
        @tab_retour = (@tab_retour, searchFormat($ref_tab->{$item},$chemin));
      } else {
        if(defined $tab{$item}) {
          $tab_retour[$#tab_retour+1] = $chemin.$item.":::".$tab{$item};
        }
      }
    }
  } elsif(ref($ref_tab) eq 'ARRAY') {
    my @tab = @{$ref_tab};
    foreach my $item (sort keys @tab) {
      my $chemin = $chemin_herite;
      if((ref($ref_tab->[$item]) eq 'HASH')or(ref($ref_tab->[$item]) eq 'ARRAY')) {
        $chemin .= $item."///";
        @tab_retour = (@tab_retour, searchFormat($ref_tab->[$item],$chemin));
      } else {
        if(defined $tab[$item]) {
          $tab_retour[$#tab_retour+1] = $chemin.$item.":::".$tab[$item];
        }
      }
    }
  }
  return @tab_retour;
}

sub composeMySearch($) {
  my($ref_tab) = @_;
  print " -------------------------\n";
  print "| Assistant de recherche |\n";
  print "-------------------------\n";
  print "Vous cherchez une donnée :\n\n";
  print "-- Protocoles disponibles ------------------------------------------------------\n";
  my $list_protocoles = getProtocole($ref_tab);
  print $list_protocoles;
  print "--------------------------------------------------------------------------------\n";
  print "Dans quel protocol se trouve-t-elle ? ";
  my $protocol_brut = <STDIN>;
  chomp($protocol_brut);
  my $protocol = convertToRegex($protocol_brut);
  print "\n-- Champs disponibles (hors tableau) -----------------------------------------\n";
  print getFieldFilter($ref_tab,$protocol);
  print "--------------------------------------------------------------------------------\n";
  print "Auriez-vous un mot clé pour décrire le champ (ex: dns.a) ? ";
  BOUCLE_COMPOSEMYSEARCH:
  my $champ_brut = <STDIN>;
  chomp($champ_brut);
  if($champ_brut eq "+") {
    clearScreen();
    print " -------------------------\n";
    print "| Assistant de recherche |\n";
    print "-------------------------\n";
    print "Vous cherchez une donnée :\n\n";
    print "-- Protocoles disponibles -----------------------------------------------------\n";
    print $list_protocoles;
    print "-------------------------------------------------------------------------------\n";
    print "Dans quel protocol se trouve-t-elle ? ";
    print $protocol_brut."\n";
    print "\n-- Champs disponibles (hors tableau) ------------------------------------------\n";
    print getFieldFilter($ref_tab,$protocol,1);
    print "-------------------------------------------------------------------------------\n";
    print "Auriez-vous un mot clé pour décrire le champ (ex: dns.a) ? ";
    goto BOUCLE_COMPOSEMYSEARCH;
  }
  my $champ = convertToRegex($champ_brut);
  print "\nAuriez-vous une regex matchant la syntaxe de la donnée à récupérer ? ";
  my $regex_donnee = <STDIN>;
  chomp($regex_donnee);
  if($regex_donnee eq '') {
    print "\n--------------------------------------------------------------------------------\n";
    print getFirstLineField($ref_tab,$protocol,$champ);
    print "-------------------------------------------------------------------------------\n";
    print "\nPourriez-vous saisir un exemple de valeur dans laquelle retrouver la donnée (délimité la partie à récupérer par des \"///\") ? \n";
    my $value_exemple = <STDIN>;
    chomp($value_exemple);
    print "\n";
    $value_exemple =~ s/\\//g;
    my $pos1 = index($value_exemple, '///');
    my $pos2 = rindex($value_exemple, '///');
    my $part1 = convertToRegex(substr($value_exemple,0,$pos1));
    my $part2 = substr($value_exemple,$pos1+3,$pos2-3-$pos1);
    my $part3 = convertToRegex(substr($value_exemple,$pos2+3));
    my %tab_chars;
    my $list_chars = "";
    my $traitement_part2 = $part2;
    if($traitement_part2 =~ /[0-9]/) {
      $traitement_part2 =~ s/[0-9]//g;
      $list_chars .= "0-9";
    }
    if($traitement_part2 =~ /[A-Z]/) {
      $traitement_part2 =~ s/[A-Z]//g;
      $list_chars .= "A-Z";
    }
    if($traitement_part2 =~ /[a-z]/) {
      $traitement_part2 =~ s/[a-z]//g;
      $list_chars .= "a-z";
    }
    my $limit = length($traitement_part2);
    foreach my $index_char(0..$limit) {
      my $select_char = substr($traitement_part2,$index_char,1);
      if(!exists $tab_chars{$select_char}) {
        $tab_chars{$select_char} = '';
      }
    }
    foreach my $select_char(sort(keys %tab_chars)) { $list_chars .= $select_char; } #implode
    $regex_donnee = $part1."([".$list_chars."]+)".$part3;
  }
  return $protocol."\\/\\/\\/.*".$champ.".*:::".$regex_donnee;
}

sub search($$;$;$) {
  my($ref_tab,$research,$is_regex,$nbr_match_recup) = @_;
  my @tab = @{$ref_tab};
  my $use_regex = 0;
  if(defined $is_regex) {
    if($is_regex == 1) {
      $use_regex = 1;
    }
  }
  if(!defined $nbr_match_recup) {
    $nbr_match_recup = 1;
  }
  my @found;
  foreach my $line(@tab) {
    if($use_regex == 1) {
      if($line =~ /$research/) { ### /\Q$research/
        $found[++$#found][0] = $line;
        # switch ($nbr_match_recup) {
        #   case 2 { $found[$#found][1] = $2 }
        #   case 3 { $found[$#found][1] = $3 }
        #   case 4 { $found[$#found][1] = $4 }
        #   case 5 { $found[$#found][1] = $5 }
        #   else   { $found[$#found][1] = $1 }
        # }
        $found[$#found][1] = $1;
      }
    } else {
      if(index($line,$research)) {
        $found[++$#found][0] = $line;
        $found[$#found][1] = getValue($line);
      }
    }
  }
  return @found;
}

sub getFieldFilter($$;$) {
  my($ref_tab,$protocole,$all) = @_;
  if(!defined $all) {
    $all = 0;
  }
  if($all == 1) {
    $all = '.*\/\/\/';
  } else {
    $all = '';
  }
  my @tab = @{$ref_tab};
  my $coupure = 8;
  my $compteur = 0;
  my %champs;
  my $result = '';
  foreach my $line (@tab) {
    if($line =~ /[0-9]+\/\/\/_source\/\/\/layers\/\/\/$protocole\/\/\/($all)?([A-Za-z0-9._-]+):::/) {
      if(defined $2) {
        my $champ = $2;
        if(!exists $champs{$champ}) {
          $compteur++;
          $champs{$champ} = '';
          if($compteur != 1) {
            $result .= '    ';
          }
          $result .= $champ;
          if($compteur == $coupure) {
            $compteur = 0;
            $result .= "\n";
          }
        }
      }
    }
  }
  if(length($result) > 0) {
    if(!(substr($result,-1) eq "\n")) {
      $result .= "\n";
    }
  }
  return $result;
}

sub getProtocole($) {
  my($ref_tab) = @_;
  my @tab = @{$ref_tab};
  my $coupure = 8;
  my $compteur = 0;
  my %protocoles;
  my $result = '';
  foreach my $line (@tab) {
    if($line =~ /[0-9]+\/\/\/_source\/\/\/layers\/\/\/([A-Za-z0-9._-]+)\/\/\//) {
      my $protocole = $1;
      if(!exists $protocoles{$protocole}) {
        $compteur++;
        $protocoles{$protocole} = '';
        if($compteur != 1) {
          $result .= '    ';
        }
        $result .= $protocole;
        if($compteur == $coupure) {
          $compteur = 0;
          $result .= "\n";
        }
      }
    }
  }
  if(length($result) > 0) {
    if(!(substr($result,-1) eq "\n")) {
      $result .= "\n";
    }
  }
  return $result;
}

sub getFirstLineField($$$) {
  my($ref_tab,$protocol,$champ) = @_;
  my @tab = @{$ref_tab};
  my $limit = 3;
  my $compteur = 0;
  my $result = '';
  foreach my $line (@tab) {
    if($line =~ /[0-9]+\/\/\/_source\/\/\/layers\/\/\/$protocol\/\/\/(.*\/\/\/)?$champ\:::(.+)/) {
      $compteur++;
      $result .= $2."\n";
      if($compteur == $limit) {
        exit();
      }
    }
  }
  return $result;
}

sub getPath($) {
  my($path_and_value) = @_;
  if(index($path_and_value,':::')) {
    return substr($path_and_value,0,index($path_and_value,':::'));
  } else {
    return $path_and_value;
  }
}

sub getField($) {
  my($path_and_value) = @_;
  if((index($path_and_value,':::'))and(rindex($path_and_value,'/'))) {
	my $pos1 = rindex($path_and_value,'/')+1;
	my $pos2 = index($path_and_value,':::');
    return substr($path_and_value,$pos1,$pos2-$pos1);
  } else {
    return $path_and_value;
  }
}

sub getValue($) {
  my($path_and_value) = @_;
  if(index($path_and_value,':::')) {
    return substr($path_and_value,index($path_and_value,':::')+3);
  } else {
    return $path_and_value;
  }
}

sub convertToRegex($) {
  my($string) = @_;
  return quotemeta $string;
}

sub clearScreen() {
  system('clear');
}

sub printArray($;$) {
  my($ref_tab,$espace) = @_;
  my $nbr_args = $#_;
  my @tab = @{$ref_tab};
  if(!defined $espace) {
    $espace = '';
  }
  if($nbr_args == 0) {
    print "Tableau {\n";
  }
  foreach my $index(keys @tab) {
    if(ref($ref_tab->[$index]) eq 'ARRAY') {
      my $nv_espace = $espace.'  ';
      printArray($ref_tab->[$index], $nv_espace);
    } else {
      print $espace."[".$index."] ".$tab[$index]."\n";
    }
  }
  if($nbr_args == 0) {
    print "}\n";
  }
}
